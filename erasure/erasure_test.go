package erasure

import (
	"bytes"
	"testing"
)

func TestCRSEncode(t *testing.T) {
	w := 4
	// data chunks
	k := 4
	// coding chunks
	m := 2
	packetsize := 8
	stripesize := packetsize * w
	data := make([][]byte, k)
	for i := range data {
		data[i] = make([]byte, stripesize)
	}
	data[0] = []byte{
		0x8b, 0xe3, 0xeb, 0x02, 0x03, 0x5f, 0xc5, 0x99,
		0x14, 0x2f, 0xf4, 0x2b, 0xe7, 0x72, 0x85, 0xb3,
		0x85, 0xeb, 0x30, 0x9a, 0xee, 0xd4, 0x5d, 0xb1,
		0x42, 0xeb, 0xcb, 0x48, 0xc5, 0xb3, 0x8e, 0x24,
	}
	data[1] = []byte{
		0x7d, 0x1a, 0xd1, 0x16, 0x58, 0x50, 0x5e, 0xf4,
		0x3a, 0xd0, 0x77, 0x0c, 0x05, 0x6b, 0xd4, 0x2a,
		0xea, 0x5a, 0x81, 0x87, 0xb1, 0xc1, 0xf2, 0xb4,
		0xa7, 0x8a, 0x7c, 0x61, 0x77, 0x0d, 0x6a, 0xde,
	}
	data[2] = []byte{
		0x44, 0xf7, 0xbf, 0xa7, 0x24, 0xda, 0xf9, 0x6f,
		0x26, 0xbb, 0x2c, 0xe7, 0x69, 0xc1, 0x36, 0x74,
		0xc3, 0xff, 0xb0, 0x67, 0x47, 0x8d, 0xdd, 0xd1,
		0xb9, 0xe9, 0x75, 0xe3, 0x49, 0xd1, 0x58, 0xcc,
	}
	data[3] = []byte{
		0x16, 0x08, 0xd4, 0x3a, 0x5b, 0xfd, 0x95, 0x6d,
		0x8e, 0xcf, 0x4c, 0x36, 0x56, 0x1b, 0xc8, 0xc3,
		0x5d, 0x4e, 0xcc, 0xf5, 0xb3, 0x2c, 0x45, 0xcf,
		0x6d, 0x60, 0xac, 0xc4, 0x0d, 0x26, 0x7a, 0x5a,
	}

	coding := make([][]byte, m)
	for i := range coding {
		coding[i] = make([]byte, stripesize)
	}

	// coding matrix is a [w*m][w*k]
	// omit data matrix since it is systematic
	matrix := GenerateCRSBitMatrix(k, m, w)
	if len(matrix) != w*w*m*k {
		t.Fatalf("len(matrix) = %d, want %d", len(matrix), w*w*m*k)
	}

	EncodeBitMatrix(k, m, w, matrix, data, coding, stripesize, packetsize)

	datai := make([]int, k)
	decodematrix := make([]int, w*w*k*k)

	// erasure the first and second data chunk
	DecodeBitMatrix(k, m, w, matrix, []int{1, 1, 0, 0, 0, 0}, decodematrix, datai)
	survivors := append(data[2:], coding...)

	// recover one by one
	ndata := make([][]byte, k)
	for i := range ndata {
		ndata[i] = make([]byte, stripesize)
	}
	EncodeBitMatrix(k, 1, w, decodematrix[:k*w*w*1], survivors, ndata, stripesize, packetsize)
	EncodeBitMatrix(k, 1, w, decodematrix[k*w*w*1:k*w*w*2], survivors, ndata[1:], stripesize, packetsize)
	EncodeBitMatrix(k, 1, w, decodematrix[k*w*w*2:k*w*w*3], survivors, ndata[2:], stripesize, packetsize)
	EncodeBitMatrix(k, 1, w, decodematrix[k*w*w*3:k*w*w*4], survivors, ndata[3:], stripesize, packetsize)

	for i := range data {
		if !bytes.Equal(data[i], ndata[i]) {
			t.Fatalf("data is not equal")
		}
	}
}
